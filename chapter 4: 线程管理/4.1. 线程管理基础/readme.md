## 4.1 线程管理基础

### 1. 启动线程

在cpp11的thread中，和其他语言的线程库有所区别。一个线程从初始化创建完毕即开始执行。

### 2. 结束线程与结束模式

在thread的使用中，线程的结束就发生在所执行的函数结束时，但是不做任何处理等待线程结束会抛出异常（因为父线程结束时子线程不一定结束，这时会抛出异常）。因此，必须在子线程结束之前，设定好子线程的**结束模式**。

**结束模式**有两种：**加入式**和**分离式**。

+ 加入式：调用子线程的join方法设定结束模式为加入式。子线程创建后就开始和父线程一起并发执行，父线程先执行到join()方法的代码时会被阻塞，直到子线程执行完毕，才能够解除阻塞继续执行join()后的代码。从而能够保证子线程在父线程结束之前正常结束，由join()方法回收子线程的资源。

+ 分离式：调用detach方法设定父子线程终止关系为分离式。子线程创建后就和父线程分别独立并发执行，使用这种结束方式，父线程不再具备控制子线程的能力，子线程可以独立于父线程一直运行下去。因此分离式线程常常作为后台一直运行处理后台操作的线程，这些线程处理文件管理，网络连接等工作持续执行到整个应用程序退出为止，最后的资源回收由

如下的两张自制图简单说明了两种线程结束模式的具体区别，可以很好的帮助理解线程的结束模式。

+ 加入式: join方法  

![avatar](https://github.com/Happyxianyueveryday/cpp-concurrency/blob/master/chapter%204:%20%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/4.1.%20%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/pics/QQ%E6%88%AA%E5%9B%BE20190831113033.png)

+ 分离式: detach方法  

![avatar](https://github.com/Happyxianyueveryday/cpp-concurrency/blob/master/chapter%204:%20%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/4.1.%20%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/pics/QQ%E6%88%AA%E5%9B%BE20190831114821.png)

### 3. 示例代码
./src下提供了两种线程结束模式的简单示例，运行后可以对照代码分析两种线程结束模式的不同。


