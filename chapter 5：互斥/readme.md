## 5. 互斥

### 1. 互斥信号量——std::mutex

cpp在mutex头文件中提供了最基本的互斥信号量，即std::mutex。

互斥信号量std::mutex提供如下两个方法用于互斥操作：

```
* lock(): 对信号量进行加锁，相当于PV操作中的P操作。
* unlock(): 对信号量进行解锁，相当于PV操作中的V操作。
```


互斥信号量std::mutex的使用方法为：

+ 将需要访问临界资源的临界区代码夹在lock()方法(P操作)和unlock()方法(V操作)之间

在直接使用裸信号量std::mutex时，必须谨慎处理，在临界区代码结束后必须记得使用unlock()方法解除互斥锁（尤其是分支代码很多且可能抛出异常的情况）。这也是推荐使用RAII的互斥信号量——lock_guard的原因。

> 警告：std::mutex默认初始化得到的对象是未加锁的，仅能通过调用lock()和unlock()方法进行上锁和解锁。


### 2. RAII互斥信号量管理器——lock_guard

因为使用裸互斥量std::mutex时，用户很容易在某些分支代码中调用lock()和unlock()方法进行加锁或者解锁。因此，cpp11提供了RAII生命周期自管理的互斥信号量管理器——lock_guard。

**lock_guard不应当作为信号量看待，它只是一个信号量的自动加锁解锁管理器，

lock_guard的结构非常简单，除了构造函数和析构函数外，没有任何的其他方法，禁止一切形式的拷贝和移动操作，提供的方法有：

```
* 构造函数：接受一个mutex对象进行绑定，创建对应的lock_guard对象，并对信号量加锁。
* 析构函数：对绑定的信号量解锁。
```

因此，从lock_guard对象创建到lock_guard退出生存期被析构之间的代码全部处于互斥信号量保护范围。






